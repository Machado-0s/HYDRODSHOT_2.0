name: Building
run-name: Building
on:
  push:
    branches: [ '*' ]        # запуск на любой ветке
    tags: [ 'v*' ]           # дополнительно на тегах, начинающихся с v (например, v1.0.0)
  workflow_dispatch:         # возможность запуска вручную

jobs:
  Build-F4:
    runs-on: ubuntu-latest
    container:
      image: seajackal/hydrodrivers:latest
    steps:
      - uses: actions/checkout@v4
      - run: git submodule update --init --recursive
      - run: cmake --preset DebugF4
      - run: cmake --build ./build

      # Шаг 1: определить пути к собранным файлам (зависит от структуры вашего проекта)
      # Например, если после сборки бинарники лежат в build/ с расширениями .bin и .elf
      - name: Find firmware files
        id: find_files
        run: |
          # Ищем файлы .bin и .elf внутри папки build
          BIN_FILE=$(find build -name "*.bin" | head -n 1)
          ELF_FILE=$(find build -name "*.elf" | head -n 1)
          echo "bin=$BIN_FILE" >> $GITHUB_OUTPUT
          echo "elf=$ELF_FILE" >> $GITHUB_OUTPUT
          echo "Found BIN: $BIN_FILE"
          echo "Found ELF: $ELF_FILE"

      # Шаг 2: загрузить артефакты (доступны для скачивания из summary workflow)
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: firmware-f4
          path: |
            ${{ steps.find_files.outputs.bin }}
            ${{ steps.find_files.outputs.elf }}
          if-no-files-found: error

      # Шаг 3: если запуск произошёл по тегу, создать релиз и загрузить файлы
      - name: Create Release and Upload Assets
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.find_files.outputs.bin }}
            ${{ steps.find_files.outputs.elf }}
          generate_release_notes: true   # автоматически добавить заметки (можно отключить)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
